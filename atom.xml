<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jxlxy1995&#39;s blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-23T15:28:03.058Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>jxlxy1995</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vector插入n个相同元素性能对比</title>
    <link href="http://yoursite.com/2021/03/23/vector%E6%8F%92%E5%85%A5n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2021/03/23/vector%E6%8F%92%E5%85%A5n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</id>
    <published>2021-03-23T13:33:55.000Z</published>
    <updated>2021-03-23T15:28:03.058Z</updated>
    
    
    <summary type="html">&lt;p&gt;写了一段测试程序对比插入n个相同元素到一个vector中消耗的时间，顺便总结一些相关概念。&lt;/p&gt;</summary>
    
    
    
    <category term="STL" scheme="http://yoursite.com/categories/STL/"/>
    
    
    <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="stl" scheme="http://yoursite.com/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>配置gdb调试时显示STL容器具体内容若干坑</title>
    <link href="http://yoursite.com/2021/03/16/%E9%85%8D%E7%BD%AEgdb%E8%B0%83%E8%AF%95%E6%97%B6%E6%98%BE%E7%A4%BASTL%E5%AE%B9%E5%99%A8%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%E8%8B%A5%E5%B9%B2%E5%9D%91/"/>
    <id>http://yoursite.com/2021/03/16/%E9%85%8D%E7%BD%AEgdb%E8%B0%83%E8%AF%95%E6%97%B6%E6%98%BE%E7%A4%BASTL%E5%AE%B9%E5%99%A8%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%E8%8B%A5%E5%B9%B2%E5%9D%91/</id>
    <published>2021-03-15T16:16:27.000Z</published>
    <updated>2021-03-23T15:27:59.173Z</updated>
    
    
    <summary type="html">&lt;p&gt;上周四工作时领导发现我用户目录下的gdb竟然不能在调试时正常打印stl容器中的内容，然后在我目录下加了一份.gdbinit文件，内容很简单只有一行,如下。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;set auto-load safe-path / &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后就可以了，但后面我在自己云主机上也照做后，发现并不管用，于是开始一系列的尝试。&lt;/p&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="gdb" scheme="http://yoursite.com/tags/gdb/"/>
    
    <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>微信抢红包分配算法</title>
    <link href="http://yoursite.com/2021/03/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2021/03/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-10T13:58:11.000Z</published>
    <updated>2021-03-10T14:45:26.978Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近工作上又一个需求是对一个数字进行随机分段，这个需求很像是微信抢红包的模型。在网上简单看了看，主要有以下两种方法，记录一下，其中第二种方法和我一开始的思路比较一致，后面选择的也是第二个。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>linux下Socket编程</title>
    <link href="http://yoursite.com/2021/01/26/linux%E4%B8%8BSocket%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/01/26/linux%E4%B8%8BSocket%E7%BC%96%E7%A8%8B/</id>
    <published>2021-01-26T15:17:49.000Z</published>
    <updated>2021-03-08T15:51:56.667Z</updated>
    
    
    <summary type="html">&lt;p&gt;游戏服务器开发说到底根本技术在两点网络通信和数据库读写，所以最近先把linux下的socket编程再系统复习一遍。&lt;/p&gt;</summary>
    
    
    
    <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Makefile简易教程</title>
    <link href="http://yoursite.com/2021/01/17/Makefile%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/01/17/Makefile%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</id>
    <published>2021-01-17T14:10:11.000Z</published>
    <updated>2021-02-01T16:02:57.421Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Makefile简介&quot;&gt;&lt;a href=&quot;#Makefile简介&quot; class=&quot;headerlink&quot; title=&quot;Makefile简介&quot;&gt;&lt;/a&gt;Makefile简介&lt;/h1&gt;&lt;p&gt;在软件开发中，make通常被视为一种软件构建工具。该工具主要经由读取一种名为“makefile”或“Makefile”的文件来实现软件的自动化建构。它会通过一种被称之为“target”概念来检查相关文件之间的依赖关系，这种依赖关系的检查系统非常简单，主要通过对比文件的修改时间来实现。在大多数情况下，我们主要用它来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。&lt;/p&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="Makefile" scheme="http://yoursite.com/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>yaml-cpp使用备忘</title>
    <link href="http://yoursite.com/2021/01/17/yaml-cpp%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/"/>
    <id>http://yoursite.com/2021/01/17/yaml-cpp%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</id>
    <published>2021-01-17T13:46:18.000Z</published>
    <updated>2021-01-17T13:49:43.796Z</updated>
    
    
    <summary type="html">&lt;p&gt;yaml是一种读取配置文件的开源库，新项目主要使用的是这个作为读取配置的工具（之前是xml和json，后面有空可以做个之间的对比）。但cpp并没有原生的读取yaml文件的接口，所以我们需要下载源码然后编译生成库文件。&lt;/p&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="yaml" scheme="http://yoursite.com/tags/yaml/"/>
    
    <category term="cpp" scheme="http://yoursite.com/tags/cpp/"/>
    
    <category term="第三方库" scheme="http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Next主题相关配置</title>
    <link href="http://yoursite.com/2021/01/06/next%E4%B8%BB%E9%A2%98%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2021/01/06/next%E4%B8%BB%E9%A2%98%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</id>
    <published>2021-01-06T13:26:17.000Z</published>
    <updated>2021-01-17T13:47:13.314Z</updated>
    
    
    <summary type="html">next主题相关配置记录</summary>
    
    
    
    <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Next主题" scheme="http://yoursite.com/tags/Next%E4%B8%BB%E9%A2%98/"/>
    
    <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>全排列简介</title>
    <link href="http://yoursite.com/2020/11/07/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/11/07/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%80%E4%BB%8B/</id>
    <published>2020-11-07T14:54:50.000Z</published>
    <updated>2021-01-06T13:20:06.337Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近打算把印象笔记记的笔记慢慢地写成博客的形式归档起来，也算是给自己的一个督促。  &lt;/p&gt;
&lt;h2 id=&quot;1-基础概念&quot;&gt;&lt;a href=&quot;#1-基础概念&quot; class=&quot;headerlink&quot; title=&quot;1.基础概念&quot;&gt;&lt;/a&gt;1.基础概念&lt;/h2&gt;&lt;p&gt;这个概念最早接触是在高中时学oi在那本老旧的竞赛书上接触到的。抛出的问题类似于&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;写一个函数, 如 Foo(const char *str), 打印出 str 的全排列, 如 abc 的全排列: abc, acb, bca, dac, cab, cba。。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;排列和组合的区别就在于是否是有顺序的，全排列从字面上的意思就是列出所有元素的排列，其实这个直观的理解是没有错的。不过还是查一下网上的定义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。&lt;br&gt;公式：全排列数f(n)=n!(定义0!=1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上就可以大概了解全排列是个什么东西了。那么直接上一版最简单的通过递归实现的全排列代码。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="全排列" scheme="http://yoursite.com/tags/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>markdown学习</title>
    <link href="http://yoursite.com/2017/07/02/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/07/02/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2017-07-02T15:53:51.000Z</published>
    <updated>2021-01-26T15:19:05.466Z</updated>
    
    
    <summary type="html">&lt;p&gt;既然想着开始用github+hexo写博客了，那么最入门的就是学习一下markdown的书写语法了。&lt;/p&gt;</summary>
    
    
    
    <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="其他技术" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/"/>
    
    <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://yoursite.com/2017/07/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/07/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2017-07-02T15:47:56.000Z</published>
    <updated>2017-07-02T15:57:13.216Z</updated>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
