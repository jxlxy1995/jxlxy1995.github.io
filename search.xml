<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>全排列简介</title>
    <url>/2020/11/07/%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>最近打算把印象笔记记的笔记慢慢地写成博客的形式归档起来，也算是给自己的一个督促。  </p>
<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><p>这个概念最早接触是在高中时学oi在那本老旧的竞赛书上接触到的。抛出的问题类似于</p>
<blockquote>
<p>写一个函数, 如 Foo(const char *str), 打印出 str 的全排列, 如 abc 的全排列: abc, acb, bca, dac, cab, cba。。  </p>
</blockquote>
<p>排列和组合的区别就在于是否是有顺序的，全排列从字面上的意思就是列出所有元素的排列，其实这个直观的理解是没有错的。不过还是查一下网上的定义。</p>
<blockquote>
<p>从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。<br>公式：全排列数f(n)=n!(定义0!=1)</p>
</blockquote>
<p>以上就可以大概了解全排列是个什么东西了。那么直接上一版最简单的通过递归实现的全排列代码。</p>
<a id="more"></a>

<h2 id="2-全排列递归实现方式"><a href="#2-全排列递归实现方式" class="headerlink" title="2.全排列递归实现方式"></a>2.全排列递归实现方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">allRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = nums.size();</span><br><span class="line">		<span class="keyword">if</span> (k == len - <span class="number">1</span>) &#123;</span><br><span class="line">			ans.push_back(nums);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; ++i) &#123;</span><br><span class="line">				swap(nums[k], nums[i]);</span><br><span class="line">				allRange(nums, k + <span class="number">1</span>);</span><br><span class="line">				swap(nums[k], nums[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">		allRange(nums, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体解决的是LeetCode上<a href="https://leetcode-cn.com/problems/permutations/">P46.全排列问题</a>。  </p>
<p>可以看到，代码中是一直在做交换。那么是如何交换的呢。可以简单用个例子展示一下，比如123。123的全排列有123、132、213、231、312、321这六种。首先考虑213和321这二个数是如何得出的。显然这二个都是123中的1与后面两数交换得到的。然后可以将123的第二个数和每三个数交换得到132。同理可以根据213和321来得231和312。因此可以得出 <strong>全排列就是从第一个数字起每个数分别与它后面的数字交换。</strong>  </p>
<p>这样一个简单的全排列解决方案就完成了。可是如果遇到元素结合里有重复元素，则会出现重复排列的情况。比如122，按照这个算法会出现多个重复的排列。  </p>
<p>那么继续按照上面的思路，由于 __由于全排列就是从第一个数字起每个数分别与它后面的数字交换__，我们先尝试加个这样的判断——如果一个数与后面的数字相同那么这二个数就不交换了。如122，第一个数与后面交换得212、221。然后122中第二数就不用与第三个数交换了，但对212，它第二个数与第三个数是不相同的，交换之后得到221。与由122中第一个数与第三个数交换所得的221重复了。所以这个方法不行。  </p>
<p>换种思维，对122，第一个数1与第二个数2交换得到212，然后考虑第一个数1与第三个数2交换，此时由于第三个数等于第二个数，所以第一个数不再与第三个数交换。再考虑212，它的第二个数与第三个数交换可以得到解决221。此时全排列生成完毕。  </p>
<p>这样我们也得到了在全排列中去掉重复的规则—— __去重的全排列就是从第一个数字起每个数分别与它后面非重复出现的数字交换__。用编程的话描述就是第i个数与第j个数交换时，要求[i,j)中没有与第j个数相等的数。下面给出一份示例代码：  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSwaped</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] == nums[end]) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">allRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = nums.size();</span><br><span class="line">		<span class="keyword">if</span> (k == len - <span class="number">1</span>) &#123;</span><br><span class="line">			ans.push_back(nums);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; len; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!isSwaped(nums, k, i)) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				swap(nums[k], nums[i]);</span><br><span class="line">				allRange(nums, k + <span class="number">1</span>);</span><br><span class="line">				swap(nums[k], nums[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">		allRange(nums, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体解决的问题是LeetCode上<a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>全排列</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题相关配置</title>
    <url>/2021/01/06/next%E4%B8%BB%E9%A2%98%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="设置hexo首页只显示部分摘要"><a href="#设置hexo首页只显示部分摘要" class="headerlink" title="设置hexo首页只显示部分摘要"></a>设置hexo首页只显示部分摘要</h1><p>只针对Next主题，不确保对于其它主题有效（但从修改模式来看，是有效的）</p>
<p>Next默认是会显示全文的，这样显然很不方便，因此需要一些方法去只显示前面一部分。</p>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>首先需要在Next主题的_config.yml中把设置打开：(默认安装时就打开了)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>然后有两种方法</p>
<h2 id="写概述"><a href="#写概述" class="headerlink" title="写概述"></a>写概述</h2><p>在文章的<code>front-matter</code>中添加<code>description</code>，其中description中的内容就会被显示在首页上，其余一律不显示。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>比较不方便的是还得写一下概述，很多时候会懒得写概述，于是就需要第二种方法了。</p>
<h2 id="文章截断"><a href="#文章截断" class="headerlink" title="文章截断"></a>文章截断</h2><p>在需要截断的地方加入：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。</p>
<h1 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h1><h2 id="安装exo-generator-searchdb这个插件"><a href="#安装exo-generator-searchdb这个插件" class="headerlink" title="安装exo-generator-searchdb这个插件"></a>安装exo-generator-searchdb这个插件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-searchdb</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure>
<h2 id="站点配置文件添加并修改local-search"><a href="#站点配置文件添加并修改local-search" class="headerlink" title="站点配置文件添加并修改local_search"></a>站点配置文件添加并修改local_search</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="设置侧栏阅读进度百分比"><a href="#设置侧栏阅读进度百分比" class="headerlink" title="设置侧栏阅读进度百分比"></a>设置侧栏阅读进度百分比</h1><p>编辑站点配置文件，修改 back2top 部分如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="设置网页底部信息"><a href="#设置网页底部信息" class="headerlink" title="设置网页底部信息"></a>设置网页底部信息</h1><p>查看主题配置文件，修改 footer 配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2017</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/icons</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#00BFFF&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Powered by Hexo &amp; NexT</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="主页文章添加置顶图标-可选"><a href="#主页文章添加置顶图标-可选" class="headerlink" title="主页文章添加置顶图标(可选)"></a>主页文章添加置顶图标(可选)</h1><p>修改主题的/layout/_macro/post.swig 文件，在“置顶” 标识下，加入如下描述：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-thumb-tack&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>&#123;&#123; __(&#x27;post.sticky&#x27;) &#125;&#125;<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="设置代码块复制和代码高亮"><a href="#设置代码块复制和代码高亮" class="headerlink" title="设置代码块复制和代码高亮"></a>设置代码块复制和代码高亮</h1><p>在主题配置文件中修改codeblock</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">style:</span></span><br></pre></td></tr></table></figure>
<h1 id="文章加上访问量"><a href="#文章加上访问量" class="headerlink" title="文章加上访问量"></a>文章加上访问量</h1><p>打开主题的配置文件/theme/next/_config.yml，找到如下配置busuanzi_count（不蒜子）启用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h1><p>修改主题配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/xxxxx</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">xxxxxxxxxx@qq.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="attr">Bili:</span> <span class="string">https://space.bilibili.com/xxxxxx</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tv</span></span><br></pre></td></tr></table></figure>
<h1 id="添加侧栏友情链接"><a href="#添加侧栏友情链接" class="headerlink" title="添加侧栏友情链接"></a>添加侧栏友情链接</h1><p>在主题配置文件中修改Blog rolls</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">links_settings:</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">fa</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Friend</span> <span class="string">Links</span></span><br><span class="line">  <span class="attr">layout:</span> <span class="string">inline</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">V2EX:</span> <span class="string">https://www.xxxx.com/</span></span><br><span class="line">  <span class="comment">#Title: http://yoursite.com</span></span><br></pre></td></tr></table></figure>
<h1 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h1><p>next集成的评论系统很多，本站用的是第三方的来必力，一个韩国评论系统。登陆 <a href="https://livere.com/">来必力</a> 获取你的 LiveRe UID。 编辑 <strong>主题配置文件</strong>， 编辑 <code>livere_uid</code> 字段（不用带引号），设置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">livere_uid:</span> <span class="comment">#your livere_uid</span></span><br></pre></td></tr></table></figure>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://blog.csdn.net/yueyue200830/article/details/104470646/">设置hexo首页只显示部分摘要（不显示全文）</a></li>
<li><a href="https://blog.csdn.net/qq_35396510/article/details/105953460">hexo 主题 next7.8 版本配置美化</a></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Next主题</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml-cpp使用备忘</title>
    <url>/2021/01/17/yaml-cpp%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<p>yaml是一种读取配置文件的开源库，新项目主要使用的是这个作为读取配置的工具（之前是xml和json，后面有空可以做个之间的对比）。但cpp并没有原生的读取yaml文件的接口，所以我们需要下载源码然后编译生成库文件。</p>
<a id="more"></a>

<h1 id="使用yaml-cpp"><a href="#使用yaml-cpp" class="headerlink" title="使用yaml-cpp"></a>使用yaml-cpp</h1><p>yaml-cpp 是一个开源库，地址在 github 上，<a href="https://github.com/jbeder/yaml-cpp">https://github.com/jbeder/yaml-cpp</a></p>
<p>yaml-cpp 是通过 CMake 来进行构建和编译的。</p>
<p>CMake具体细节可以先不做研究，后面只需要使用CMake对工程进行构建就好了。</p>
<p>首先下载源码。下载好后其实具体使用步骤在yaml-cpp/install.txt中也有具体描述。</p>
<p>然后，在源码目录创建一个 build 文件夹。切换到build文件夹，然后执行cmake</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure>
<p>注意的是 cmake 后面是 <code>..</code>，这代表从 build 上一层目录查找 CMakeLists.txt （如果你的build目录在别处就是别的相对路径了），然后编译的文件都会存放在 build 文件夹，如果对编译的效果不满意，只要删除 build 文件就好了，其他源码目录并不受影响，这是 cmake 编译时的基本套路。</p>
<p>yaml-cpp 默认构建的就是静态库，也就是 unix 类系统下的 .a 文件，如果你想构建动态库的话，就需要在 cmake 时指定。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake ..  -D BUILD_SHARED_LIBS=ON</span><br></pre></td></tr></table></figure>
<p>编译成功后，会生成库文件，<del>你只需要将库文件和头文件拷贝到你自己的工程当中，就可以使用了。</del></p>
<p>上面下划线是原文当中的做法，更好的做法是根据install.txt中的做法，直接执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>对应的.so文件会被安装到系统目录下去。笔者自己执行后对应yaml-cpp一系列的so文件是到了<code>usr/local/lib64</code>。</p>
<h2 id="安装新的动态库到linux"><a href="#安装新的动态库到linux" class="headerlink" title="安装新的动态库到linux"></a>安装新的动态库到linux</h2><p>这边顺带提下，安装新的三方库到linux系统下，如果不做任何处理，你直接编译执行需要使用这个库的程序是会报如下错误的</p>
<blockquote>
<p>error while loading shared libraries: libyaml-cpp.so: cannot open shared object file: No such file or directory</p>
</blockquote>
<p>意思是系统找不到对应的动态库文件***.so，一般linux系统都是去/usr/lib下找的，上面提到我们这次安装的yaml-cpp被安装到了<code>usr/local/lib64</code>。</p>
<ol>
<li>首先打开/etc/ld.so.conf文件</li>
<li>加入动态库文件所在的目录：执行<code>vim /etc/ld.so.conf</code>，在<code>&quot;include ld.so.conf.d/*.conf&quot;</code>下方增加<code>/usr/local/lib64</code>。(大部分其他库会被安装到<code>/usr/local/lib</code>下，那就加这个目录，笔者的配置这俩都已经加进去了)</li>
<li>保存后，在命令行终端执行：<code>/sbin/ldconfig -v</code>；其作用是将文件/etc/ld.so.conf列出的路径下的库文件缓存到<code>/etc/ld.so.cache</code>以供使用。因此当安装完一些库文件，或者修改<code>/etc/ld.so.conf</code>增加了库的新搜索路径，需要运行一下ldconfig，使所有的库文件都被缓存到文件/etc/ld.so.cache中，如果没做，可能会找不到刚安装的库。</li>
</ol>
<p>这样执行完后，使用了yaml-cpp的程序就能正常运行了。</p>
<p>当然稍微大点的工程在使用第三方库时肯定会在Makefile中include进去，另一篇文章会介绍一个简单工程的Makefile的编写，里面包含了如何将yaml-cpp带进自己的工程中去编译使用。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/briblue/article/details/89515470">c++ 开发中利用yaml-cpp读写yaml配置文件</a></p>
<p><a href="https://blog.csdn.net/hankerbit/article/details/83834349">Linux中error while loading shared libraries错误解决办法</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>yaml</tag>
        <tag>cpp</tag>
        <tag>第三方库</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile简易教程</title>
    <url>/2021/01/17/Makefile%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Makefile简介"><a href="#Makefile简介" class="headerlink" title="Makefile简介"></a>Makefile简介</h1><p>在软件开发中，make通常被视为一种软件构建工具。该工具主要经由读取一种名为“makefile”或“Makefile”的文件来实现软件的自动化建构。它会通过一种被称之为“target”概念来检查相关文件之间的依赖关系，这种依赖关系的检查系统非常简单，主要通过对比文件的修改时间来实现。在大多数情况下，我们主要用它来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。</p>
<a id="more"></a>

<h1 id="编写一个最简单的Makefile"><a href="#编写一个最简单的Makefile" class="headerlink" title="编写一个最简单的Makefile"></a>编写一个最简单的Makefile</h1><p>比如我们现在有main.cpp、func.cpp、func.h这么三个源代码文件。正常情况下我们是这样编译的（假设最后生成的目标程序叫prog）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -o prog main.cpp func.cpp</span><br></pre></td></tr></table></figure>
<p>如果没有makefile，在开发+调试程序的过程中，我们就需要不断地重复输入上面这条编译命令，要不就是通过终端的历史功能不停地按上下键来寻找最近执行过的命令。这样做两个缺陷：</p>
<ol>
<li>一旦终端历史记录被丢失，我们就不得不从头开始；</li>
<li>任何时候只要我们修改了其中一个文件，上述编译命令就会重新编译所有的文件，当文件足够多时这样的编译会非常耗时。</li>
</ol>
<p>那么Makefile又能做什么呢？我们先来看一个最简单的makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">prog: main.cpp func.cpp</span></span><br><span class="line">    g++ -o prog main.cpp func.cpp</span><br></pre></td></tr></table></figure>
<p>以上就是一个最基本的Makefile语句，它主要分成了三个部分：第一行冒号之前的prog，我们称之为目标（target），被认为是这条语句所要处理的对象，具体到这里就是我们所要编译的这个程序calc。冒号后面的部分（main.cpp func.cpp），我们称之为依赖关系表，也就是编译calc所需要的文件，<strong>这些文件只要有一个发生了变化</strong>，就会触发该语句的第三部分，我们称其为命令部分，相信你也看得出这就是一条编译命令。现在我们只要将上面这两行语句写入一个名为Makefile或者makefile的文件，然后在终端中输入make命令，就会看到它按照我们的设定去编译程序了。</p>
<blockquote>
<p>注意，在第二行的“g++”命令之前必须要有一个tab缩进。语法规定Makefile中的任何命令之前都必须要有一个tab缩进，否则make就会报错。</p>
</blockquote>
<p>接下来，让我们来解决一下效率方面的问题，先初步修改一下上面的代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = prog</span><br><span class="line">SOURCE = main.cpp func.cpp</span><br><span class="line"> </span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(SOURCE)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(SOURCE)</span></span><br></pre></td></tr></table></figure>
<p>我们在上述代码中定义了三个常量CXX、TARGET以及SOURCE。它们分别告诉了make我们要使用的编译器、要编译的目标以及源文件。这样一来，今后我们要修改这三者中的任何一项，只需要修改常量的定义即可，而不用再去管后面的代码部分了。</p>
<p>但我们现在依然还是没能解决当我们只修改一个文件时就要全部重新编译的问题。而且如果我们修改的是func.h文件，make就无法察觉到变化了（所以有必要为头文件专门设置一个变量，并将其加入到依赖关系表中）。下面，我们来想一想如何解决这个问题。考虑到在标准的编译过程中，<strong>源文件往往是先被编译成目标文件，然后再由目标文件连接成可执行文件的</strong>。我们可以利用这一点来调整一下这些文件之间的依赖关系：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = prog</span><br><span class="line">DEPS = func.h</span><br><span class="line">OBJ = main.o func.o</span><br><span class="line"> </span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(SOURCE)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(SOURCE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp <span class="variable">$(DEPS)</span></span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">func.o: func.cpp <span class="variable">$(DEPS)</span></span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c func.cpp</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>这样一来，上面的问题显然是解决了，但同时我们又让代码变得非常啰嗦，而且啰嗦往往伴随着低效率。经过再度观察，我们发现所有.cpp都会被编译成相同名称的.o文件。我们可以根据该特点再对其做进一步的简化：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = prog</span><br><span class="line">DEPS = func.h</span><br><span class="line">OBJ = main.o func.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(DEPS)</span></span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们用到了几个特殊的宏。首先是%.o:%.c，这是一个模式规则，表示所有的.o目标都依赖于与它同名的.c文件（当然还有DEPS中列出的头文件）。再来就是命令部分的$&lt;和$@，其中$&lt;代表的是依赖关系表中的第一项（如果我们想引用的是整个关系表，那么就应该使用$^），具体到我们这里就是%.c。而$@代表的是当前语句的目标，即%.o。这样一来，make命令就会自动将所有的.c源文件编译成同名的.o文件。不用我们一项一项去指定了。整个代码自然简洁了许多。</p>
<p>到目前为止，我们已经有了一个不错的makefile，至少用来维护这个小型工程是没有什么问题了。当然，如果要进一步增加上面这个项目的可扩展性，我们就会需要用到一些Makefile中的伪目标和函数规则了。例如，如果我们想增加自动清理编译结果的功能就可以为其定义一个带伪目标的规则，在上述语句后面追加：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(OBJ)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>当我们在终端中执行make clean命令时，它就会去删除该工程生成的所有编译文件。</p>
<p>另外，如果我们需要往工程中添加一个.cpp或.h，可能同时就要再手动为obj常量再添加第一个.o文件，如果这列表很长，代码会非常难看，为此，我们需要用到Makefile中的函数，这里我们演示两个：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = prog</span><br><span class="line">DEPS = <span class="variable">$(<span class="built_in">shell</span> find ./ -name &quot;*.h&quot;)</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">shell</span> find ./ -name &quot;*.cpp&quot;)</span></span><br><span class="line">OBJ = $(SRC:%.cpp=%.o) </span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c <span class="variable">$(DEPS)</span></span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line">    </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf <span class="variable">$(OBJ)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>其中，shell函数主要用于执行shell命令，具体到这里就是找出当前目录下所有的.cpp和.h文件。而$(src:%.cpp=%.o)则是一个字符替换函数，它会将src所有的.cpp字串替换成.o，实际上就等于列出了所有.c文件要编译的结果。有了这两个设定，无论我们今后在该工程加入多少.c和.h文件，Makefile都能自动将其纳入到工程中来。</p>
<h1 id="Makefile中引入第三方库写法"><a href="#Makefile中引入第三方库写法" class="headerlink" title="Makefile中引入第三方库写法"></a>Makefile中引入第三方库写法</h1><p>上面仅限于我们自己编写几个文件时的小工程使用，日常工作学习当中我们必然要使用大量第三方库，毕竟github上有着众多优质轮子，可以选择自己需要的来使用。</p>
<p>比如上一篇文章就说到了yaml-cpp，那么我们这次使用这个库作为演示。</p>
<p>假设在各个那个背景下，我们需要引入yaml-cpp库。那么我们知道，引入一个库可以使用静态库或者动态库（后面有机会可以总结下两者的区别）。这里使用动态库，在win平台下是.dll文件，linux下是.so文件。以及我们还需要include这个库的头文件（若干个）。那么我们在Makefile文件中加入这两个目录</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ROOT_DIR := ../../</span><br><span class="line">INC_DIR := <span class="variable">$(ROOT_DIR)</span>thirdlib/<span class="keyword">include</span></span><br><span class="line">LIB_DIR := <span class="variable">$(ROOT_DIR)</span>thirdlib/lib</span><br></pre></td></tr></table></figure>
<p>INC_DIR和LIB_DIR分别代表存放yaml的头文件和.so文件的目录(ROOT_DIR是整个项目根目录，每个人放工程目录不一样，理解即可)。那么我们把他们加入到我们的编译选项当中，如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LD_LIBS := yaml-cpp</span><br><span class="line">CXXFLAGS := -ggdb</span><br><span class="line">CXXFLAGS += <span class="variable">$(<span class="built_in">addprefix</span> -I, <span class="variable">$(INC_DIR)</span>)</span></span><br><span class="line">LDFLAGS  := <span class="variable">$(<span class="built_in">addprefix</span> -L,<span class="variable">$(LIB_DIR)</span>)</span> <span class="variable">$(<span class="built_in">addprefix</span> -l,<span class="variable">$(LD_LIBS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(OBJ)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>我们看到最后的编译命令在obj前面加了CXXFLAGS，也就是c++编译选项，这里就有刚刚的INC_DIR（如果有其他需要括进去的头文件目录也可以加进去，-ggdb是代表生成可供gdb是用的信息，使用-g也是类似的效果，但两者有细微的差别，一般更倾向于使用前者也就是-ggdb)。</p>
<p>LDFLAGS代表我们需要引入的库名，其中有两个命令参数，**-L** 指定库的路径 <strong>-l</strong> 指定需连接的库名。也就是上面的$(ROOT_DIR)thirdlib/include和yaml-cpp。</p>
<p>这样我们能在工程下任意文件里调用yaml-cpp的内容了，调用时加上<code>#include &quot;yaml-cpp/yaml.h&quot;</code>即可。</p>
<p>以上就是在工程中引入yaml-cpp需要对Makefile文件进行修改的简单总结了，后续这篇文章可能还会更新一些更细节的内容。诸如Makefile更优化的写法，gcc一些命令参数的对比或者备忘等等。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://blog.csdn.net/jiafu1115/article/details/8842240">gcc -I -L -l区别</a></p>
<p><a href="https://www.cnblogs.com/skying555/p/10278810.html">Makefile简易教程</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Make">中文维基百科</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>微信抢红包分配算法</title>
    <url>/2021/03/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>最近工作上又一个需求是对一个数字进行随机分段，这个需求很像是微信抢红包的模型。在网上简单看了看，主要有以下两种方法，记录一下，其中第二种方法和我一开始的思路比较一致，后面选择的也是第二个。</p>
<a id="more"></a>

<h1 id="二倍均值法"><a href="#二倍均值法" class="headerlink" title="二倍均值法"></a>二倍均值法</h1><p>假设剩余红包金额为m，剩余人数为n，那么有以下等式：</p>
<p>每次抢到的红包 = 随机区间（0, m/n * 2）</p>
<p>比如：</p>
<p>假设有十个人分红包，红包总额为100元，第一个人抢到的金额范围为(0, 100/10 * 2)，平均期望为10 元；第二个人抢到的金额范围为(0, 90/9 * 2)，平均也是10元。以此类推到第十个人也是10元。那么代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> remainValue= m;</span><br><span class="line">    <span class="keyword">int</span> remainCount = n;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> &gt;= remainCount)&#123;</span><br><span class="line">            value = remainValue;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//此处做一个简化，最少能抢到1元，如果做成浮点数对应放大即可</span></span><br><span class="line">            <span class="comment">//randBetween是我自己实现的随机函数，[low, high]两边都是闭区间，所以这种写法并不完全符合这个思想因为最后一个人会比期望多一些。此处自行理解改进即可</span></span><br><span class="line">            value = CTS::randBetween(<span class="number">1</span>, remainValue / (n - i) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        remainValue -= value;</span><br><span class="line">        --remainCount;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no.&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; get &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; remain value &quot;</span> &lt;&lt; remainValue &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<img src="/2021/03/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/image-20210310222751159.png" class="" title="image-20210310222751159">

<p>我们可以看到，虽然说期望是平均值，但其实结果还是有一定差异的（即使除去我以为随机函数导致的差异还是很大）。</p>
<h1 id="线段分割法"><a href="#线段分割法" class="headerlink" title="线段分割法"></a>线段分割法</h1><p>我们可以把总数想成是一个线段，那么如果要随机分出n端来，就只需要找出n-1个不重复的点来切割就可以了。</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cutLine</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    int32 total = m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;int32&gt; line;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;int32&gt; result;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;int32&gt; allPoint;</span><br><span class="line">    <span class="keyword">bool</span> pardon = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(total &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pardon)&#123;</span><br><span class="line">                int32 index = CTS::randBetween(<span class="number">1</span>, total - <span class="number">1</span>);</span><br><span class="line">                allPoint.insert(index);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">do</span>&#123;</span><br><span class="line">                    int32 index = CTS::randBetween(<span class="number">1</span>, total);</span><br><span class="line">                    <span class="keyword">if</span>(allPoint.find(index) == allPoint.end())&#123;</span><br><span class="line">                        allPoint.insert(index);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    line.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it: allPoint)&#123;</span><br><span class="line">        line.push_back(it);</span><br><span class="line">    &#125;</span><br><span class="line">    line.push_back(total);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int32 i = <span class="number">0</span>; i &lt; line.size() - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">        result.push_back(line[i + <span class="number">1</span>] - line[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不足部分补0</span></span><br><span class="line">    <span class="keyword">for</span>(int32 i = result.size(); i &lt; n; ++i)&#123;</span><br><span class="line">        result.push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CTS::printfVec(line);</span><br><span class="line">    CTS::printfVec(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<img src="/2021/03/10/%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95/image-20210310223817753.png" class="" title="image-20210310223817753">

<p>第一个是total为0的情况，<strong>这点需要注意一下，要不然会出现一对1和-1</strong>。第一个数组是切割点位置，包括0点和total终点；第二个数组就是n个切割出来的值了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两种方法我工作上最终选择了线段分割法，直觉上感觉这种方法更随机一些。但我这种写法消耗的时间和空间都更大（并不是指这种思路）。不过由于该子方法是一个不算很频繁的逻辑功能调用，暂且可以如此。如果后续觉得不太好，也可以进行优化掉。</p>
<p>最后说到微信红包，我在网上浏览文章时，发现有两种说法。</p>
<p>一是一些人做出大量测试，结果很偏向微信红包使用的是二倍均值法</p>
<p>二是说微信红包用的是一种更复杂的方法，详细参见这篇文章<a href="https://www.zhihu.com/question/22625187">微信红包的随机算法是怎样实现的？</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>配置gdb调试时显示STL容器具体内容若干坑</title>
    <url>/2021/03/16/%E9%85%8D%E7%BD%AEgdb%E8%B0%83%E8%AF%95%E6%97%B6%E6%98%BE%E7%A4%BASTL%E5%AE%B9%E5%99%A8%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%E8%8B%A5%E5%B9%B2%E5%9D%91/</url>
    <content><![CDATA[<p>上周四工作时领导发现我用户目录下的gdb竟然不能在调试时正常打印stl容器中的内容，然后在我目录下加了一份.gdbinit文件，内容很简单只有一行,如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set auto-load safe-path / </span><br></pre></td></tr></table></figure>
<p>然后就可以了，但后面我在自己云主机上也照做后，发现并不管用，于是开始一系列的尝试。</p>
<a id="more"></a>

<h1 id="gdb版本更新"><a href="#gdb版本更新" class="headerlink" title="gdb版本更新"></a>gdb版本更新</h1><p>一开始我看工作环境gdb版本为9.2版本，我自己的机器上的是7.6版本，那么是不是版本原因呢？先更新试试！</p>
<h2 id="下载更新新版本GDB"><a href="#下载更新新版本GDB" class="headerlink" title="下载更新新版本GDB"></a>下载更新新版本GDB</h2><p>先去<a href="http://ftp.gnu.org/gnu/gdb/">gdb官网</a> 下载新版本的gdb源码，然后发现最新的是10.1版本，那就10.1好了。</p>
<p>下载好源码解压后，在gdb-10.1目录下新建一个build目录，然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">../configure</span><br></pre></td></tr></table></figure>
<p>在build目录生成makefile，之后<code>make</code>然后<code>make install</code>即可，非root用户记得加上<code>sudo</code>。执行<code>gdb --version</code>即可查看到机器上的gdb版本变更为10.1了。</p>
<p>然后再试试，发现果然并不行- -。</p>
<h1 id="Python脚本支持？"><a href="#Python脚本支持？" class="headerlink" title="Python脚本支持？"></a>Python脚本支持？</h1><p>之后在网上一直查，发现7.0版本后的gdb打印stl容器功能其实是<code>pretty-printer</code>这个python脚本来提供的。通过在gdb中<code>info pretty-printer</code>查看是否有该脚本支持，尝试查看，果然没有。</p>
<h2 id="设置pretty-printer"><a href="#设置pretty-printer" class="headerlink" title="设置pretty-printer"></a>设置pretty-printer</h2><p>方法如下:</p>
<ol>
<li><p>获得python脚本，建议使用gcc默认安装的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo find &#x2F; -name &quot;*libstdcxx*&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>若本机查找不到python脚本，建议下载gcc对应版本源码包，相对目录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc-4.8.1&#x2F;libstdc++-v3&#x2F;python</span><br></pre></td></tr></table></figure></li>
<li><p>也可直接下载最新版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">svn co svn:&#x2F;&#x2F;gcc.gnu.org&#x2F;svn&#x2F;gcc&#x2F;trunk&#x2F;libstdc++-v3&#x2F;python</span><br></pre></td></tr></table></figure></li>
<li><p>将如下代码添加到.gdbinit文件中（我自己的机器搜出来该python脚本位于 <code>/usr/local/gcc/share/gcc-9.2.0/python/</code> 下，但是由于我的机器装东西装的比较乱，可能不止这一个目录有。。。）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;/usr/local/gcc/share/gcc-9.2.0/python&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> libstdcxx.v6.printers <span class="keyword">import</span> register_libstdcxx_printers</span><br><span class="line">register_libstdcxx_printers (<span class="literal">None</span>)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>设置好了在用户根目录<code>.gdbinit</code>文件中填入该脚本，直接在启动gdb时就报出了一个警告。完整的英文语句我有点忘记了，但意思是这个版本的gdb不支持python。</p>
</li>
</ol>
<p>不支持python？这怎么可能，我搜出来的结果基本都是指向该功能需要由python来支持。</p>
<h1 id="重新配置编译gdb源码"><a href="#重新配置编译gdb源码" class="headerlink" title="重新配置编译gdb源码"></a>重新配置编译gdb源码</h1><p>经尝试，<code>gdb10.1</code>（包括<code>9.2</code>）直接<code>../configure</code>是默认不会支持python功能的，我去啊= =。行吧那么重新来一遍</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">../configure --with-python=&quot;/usr/bin&quot;</span><br></pre></td></tr></table></figure>
<p>配置makefile文件时加上这个选项，路径为主机上python所在的目录。再次编译安装后，进入gdb界面，发现那条报错没有了！</p>
<h1 id="成功打印！"><a href="#成功打印！" class="headerlink" title="成功打印！"></a>成功打印！</h1><p>令人高兴的是，加上python编译选项后gdb正确的打印出了我想要的东西，样子如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) p vec</span><br><span class="line"><span class="variable">$1</span> = std::vector of length 10, capacity 10 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br></pre></td></tr></table></figure>
<p>而原来是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) p vec</span><br><span class="line"><span class="variable">$1</span> = &#123;&lt;std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;&gt; = &#123;</span><br><span class="line">    _M_impl = &#123;&lt;std::allocator&lt;int&gt;&gt; = &#123;&lt;__gnu_cxx::new_allocator&lt;int&gt;&gt; = &#123;&lt;No data fields&gt;&#125;, &lt;No data fields&gt;&#125;, _M_start = 0x404010, _M_finish = 0x404038, </span><br><span class="line">          _M_end_of_storage = 0x404038&#125;&#125;, &lt;No data fields&gt;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然最后成功配置，但其实在这几天的踩坑中，还有很多细节可以记录</p>
<h2 id="gdbinit中的那段导入python的代码是否是必要的"><a href="#gdbinit中的那段导入python的代码是否是必要的" class="headerlink" title=".gdbinit中的那段导入python的代码是否是必要的"></a>.gdbinit中的那段导入python的代码是否是必要的</h2><p>我在删掉那段代码后，再次尝试是否可以正常打印stl容器内容，发现还是正常的（试过vector和set），但是使用<code>info pretty-printer</code>查看，结果和之前不太一样了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info pretty-printer</span><br><span class="line">global pretty-printers:</span><br><span class="line">  <span class="built_in">builtin</span></span><br><span class="line">    mpx_bound128</span><br></pre></td></tr></table></figure>
<p>比之前少了很多，而之前是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info pretty-printer</span><br><span class="line">global pretty-printers:</span><br><span class="line">  <span class="built_in">builtin</span></span><br><span class="line">    mpx_bound128</span><br><span class="line">  libstdc++-v6</span><br><span class="line">    __gnu_cxx::_Slist_iterator</span><br><span class="line">    __gnu_cxx::__8::_Slist_iterator</span><br><span class="line">    __gnu_cxx::__8::__normal_iterator</span><br><span class="line">    __gnu_cxx::__8::slist</span><br><span class="line">    __gnu_cxx::__normal_iterator</span><br><span class="line">    __gnu_cxx::slist</span><br><span class="line">    __gnu_debug::_Safe_iterator</span><br><span class="line">    std::_Deque_const_iterator</span><br><span class="line">    std::_Deque_iterator</span><br><span class="line">    std::_Fwd_list_const_iterator</span><br><span class="line">    std::_Fwd_list_iterator</span><br><span class="line">    std::_List_const_iterator</span><br><span class="line">    std::_List_iterator</span><br><span class="line">    std::shared_ptr</span><br><span class="line">    std::stack</span><br><span class="line">    std::tr1::shared_ptr</span><br><span class="line">    std::tr1::unordered_map</span><br><span class="line">    std::tr1::unordered_multimap</span><br><span class="line">    std::tr1::unordered_multiset</span><br><span class="line">    std::tr1::unordered_set</span><br><span class="line">    std::tr1::weak_ptr</span><br><span class="line">    std::tuple</span><br><span class="line">    std::unique_ptr</span><br><span class="line">    std::unordered_map</span><br><span class="line">    std::unordered_multimap</span><br><span class="line">    std::unordered_multiset</span><br><span class="line">    std::unordered_set</span><br><span class="line">    std::variant</span><br><span class="line">    std::vector</span><br><span class="line">    std::weak_ptr</span><br></pre></td></tr></table></figure>
<p>这个我没去仔细查，最后我选择留下了那段导入脚本。</p>
<h2 id="我机器gdb所依赖的库很奇怪"><a href="#我机器gdb所依赖的库很奇怪" class="headerlink" title="我机器gdb所依赖的库很奇怪"></a>我机器gdb所依赖的库很奇怪</h2><p>首先通过如下命令查看一个软件在linux上所依赖的库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@VM_0_12_centos ~]<span class="comment"># which gdb</span></span><br><span class="line"><span class="built_in">alias</span> gdb=<span class="string">&#x27;gdb -q&#x27;</span></span><br><span class="line">        /usr/<span class="built_in">local</span>/bin/gdb</span><br><span class="line">[root@VM_0_12_centos ~]<span class="comment"># ldd /usr/local/bin/gdb</span></span><br><span class="line">        linux-vdso.so.1 =&gt;  (0x00007ffe6c781000)</span><br><span class="line">        libncursesw.so.5 =&gt; /lib64/libncursesw.so.5 (0x00007f239664d000)</span><br><span class="line">        libtinfo.so.5 =&gt; /lib64/libtinfo.so.5 (0x00007f2396423000)</span><br><span class="line">        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f239621f000)</span><br><span class="line">        libpython2.7.so.1.0 =&gt; /lib64/libpython2.7.so.1.0 (0x00007f2395e53000)</span><br><span class="line">        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f2395c37000)</span><br><span class="line">        libutil.so.1 =&gt; /lib64/libutil.so.1 (0x00007f2395a34000)</span><br><span class="line">        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f2395732000)</span><br><span class="line">        libexpat.so.1 =&gt; /lib64/libexpat.so.1 (0x00007f2395508000)</span><br><span class="line">        libstdc++.so.6 =&gt; /usr/<span class="built_in">local</span>/gcc/lib64/libstdc++.so.6 (0x00007f239512f000)</span><br><span class="line">        libgcc_s.so.1 =&gt; /usr/<span class="built_in">local</span>/gcc/lib64/libgcc_s.so.1 (0x00007f2394f17000)</span><br><span class="line">        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f2394b4a000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f2396885000)</span><br></pre></td></tr></table></figure>
<p>其他都很正常，唯独这句</p>
<blockquote>
<p>libstdc++.so.6 =&gt; /usr/local/gcc/lib64/libstdc++.so.6 (0x00007f239512f000)</p>
</blockquote>
<p>我也是现在写才发现。。。已经变正常了，之前他索引的是一个ycm插件下自带的<code>libstdc++.so.6</code> ，这可能是gdb一开始没有索引默认gcc下的python脚本的原因（因为没报错）。在咨询过大佬同学后，让我查看机器的系统变量<code>LD_LIBRARY_PATH</code>，查询后发现就是那个错误的ycm地址。查询和修改语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/mypath</span><br></pre></td></tr></table></figure>
<p>我先把它修改成空了，让软件先走系统默认的查询lib的路径。</p>
<p>后续发现在根目录下的<code>.bashrc</code> 文件，最后一句export LD_LIBRARY_PATH = 那个奇怪的位置。也就是这句话导致该变量异常。</p>
<p>在写这篇博文的时候才发现gdb所依赖的<code>libstdc++.so.6</code>库已经变成默认正常路径下的库了，难道linux软件依赖库是动态改变的？这一点后续可以确认考证下。</p>
<h1 id="主要参考文章"><a href="#主要参考文章" class="headerlink" title="主要参考文章"></a>主要参考文章</h1><p><a href="https://github.com/hellogcc/100-gdb-tips/blob/master/src/print-STL-container.md">打印STL容器中的内容</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vector插入n个相同元素性能对比</title>
    <url>/2021/03/23/vector%E6%8F%92%E5%85%A5n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>写了一段测试程序对比插入n个相同元素到一个vector中消耗的时间，顺便总结一些相关概念。</p>
<a id="more"></a>

<h1 id="插入相同元素测试代码"><a href="#插入相同元素测试代码" class="headerlink" title="插入相同元素测试代码"></a>插入相同元素测试代码</h1><p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;int32&gt; vec1,vec2,vec3,vec4,vec5;</span><br><span class="line">int32 count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">uint64 startTick = <span class="number">0</span>;</span><br><span class="line">uint64 endTick = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;push back:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">startTick = CTS::getMsTimeStamp();</span><br><span class="line"><span class="keyword">for</span>(int32 i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">vec1.push_back(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">endTick = CTS::getMsTimeStamp();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cost time: &quot;</span> &lt;&lt; endTick - startTick &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;emplace back:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">startTick = CTS::getMsTimeStamp();</span><br><span class="line"><span class="keyword">for</span>(int32 i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">vec2.emplace_back(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">endTick = CTS::getMsTimeStamp();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cost time: &quot;</span> &lt;&lt; endTick - startTick &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;resize:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">startTick = CTS::getMsTimeStamp();</span><br><span class="line">vec3.resize(count);</span><br><span class="line"><span class="keyword">for</span>(int32 i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">vec3[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">endTick = CTS::getMsTimeStamp();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cost time: &quot;</span> &lt;&lt; endTick - startTick &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reserve:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">startTick = CTS::getMsTimeStamp();</span><br><span class="line">vec4.reserve(count);</span><br><span class="line"><span class="keyword">for</span>(int32 i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">vec4[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">endTick = CTS::getMsTimeStamp();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cost time: &quot;</span> &lt;&lt; endTick - startTick &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;resize with value:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">startTick = CTS::getMsTimeStamp();</span><br><span class="line">vec5.resize(count, <span class="number">1</span>);</span><br><span class="line">endTick = CTS::getMsTimeStamp();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cost time: &quot;</span> &lt;&lt; endTick - startTick &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">CTS::printfVec(vec1);</span><br><span class="line">CTS::printfVec(vec2);</span><br><span class="line">CTS::printfVec(vec3);</span><br><span class="line">CTS::printfVec(vec4);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;vec4 size = &quot;</span> &lt;&lt; vec4.size() &lt;&lt; <span class="string">&quot; cap = &quot;</span> &lt;&lt; vec4.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">CTS::printfVec(vec5);</span><br></pre></td></tr></table></figure>
<p>以上5个vector分别用五种不同的方式插入count个相同元素，要注意的vec是已初始化过的。如果是未初始化的容器本身vector就有初始n个相同元素的构造函数，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n, m)</span></span>;</span><br></pre></td></tr></table></figure>
<p>意为，初始化包含n个值为m的vec。</p>
<p>回到上面代码，5个vector插入元素的方法分别为：</p>
<ol>
<li>调用count次<code>push_back</code>函数</li>
<li>调用count次<code>emplace_back</code>函数</li>
<li>使用resize函数申请count个元素大小内存，在通过下标赋值</li>
<li>使用reserve函数申请count个元素大小内存，在通过下标赋值</li>
<li>使用resize函数申请count个元素大小内存同时使用其第二个参数赋上初始值</li>
</ol>
<p>在count较小的情况下，五种方法基本上没有区别，当count值很大时，时间上就会有着较大的差别，如下：</p>
<img src="/2021/03/23/vector%E6%8F%92%E5%85%A5n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/image-20210323221746893.png" class="" title="image-20210323221746893">

<p>以上结果为count为一千万时的结果，时间单位为秒。</p>
<p>可以看出，时间效率从上到下是越来越高的。</p>
<p>所以，首先得到结果，<strong>这个问题本身的答案是使用第五种方法，即使用带初始化值的resize函数</strong></p>
<p>しかし（但是，发音西噶西，哈哈哈哈）！其实上面的五种方法中，<strong>第四种方法其实是不能完成我们的需求的</strong>，如果代码count为5，打印结果是：</p>
<img src="/2021/03/23/vector%E6%8F%92%E5%85%A5n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/image-20210323223319526.png" class="" title="image-20210323223319526">

<p>vec4是没有元素被打印出来的，并且下方我打印出了它的<code>size()</code>和<code>capacity()</code>，那么这两者包括这两个函数有什么区别呢？下面来简单对比一下。</p>
<h1 id="vector的resize-，reserve-，size-和capacity"><a href="#vector的resize-，reserve-，size-和capacity" class="headerlink" title="vector的resize()，reserve()，size()和capacity()"></a>vector的resize()，reserve()，size()和capacity()</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>capacity</p>
<p>指容器在分配新的存储空间之前能存储的元素总数。</p>
</li>
<li><p>size</p>
<p>指当前容器所存储的元素个数</p>
</li>
</ol>
<p>即capacity是容器可存储的最大总数，size是当前容器存储的个数。这样就比较明白了，至于两者之间差值的那些元素是什么情况，后续来说。可以先认为是未被初始化。</p>
<ol>
<li><p>resize<br>既分配了空间，也创建了对象。</p>
<p>这里空间就是capacity，对象就是容器中的元素。</p>
</li>
<li><p>reserve<br>reserve()表示容器预留空间，但不是真正的创建对象，需要通过insert()或push_back()等操作创建对象。</p>
</li>
</ol>
<p>其实size()和capacity()没有更多需要介绍的地方，大家平时coding时直接调用即可。当然size()的使用频率相当高，通常进行遍历操作时，最外层的for循环的次数即为size()。</p>
<h2 id="resize和reverse区别"><a href="#resize和reverse区别" class="headerlink" title="resize和reverse区别"></a>resize和reverse区别</h2><ol>
<li>reserve()只修改capacity大小，不修改size大小；</li>
<li>resize()既修改capacity大小，也修改size大小。</li>
</ol>
<p>有如下示例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">a.reserve(<span class="number">100</span>);</span><br><span class="line">a.resize(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">a.resize(<span class="number">150</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">a.reserve(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">a.resize(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;a.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<img src="/2021/03/23/vector%E6%8F%92%E5%85%A5n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/image-20210323224953990.png" class="" title="image-20210323224953990">

<p>可以看出，和如上所说的一样。且最后一个操作表明，resize一个原来capacity更大的vector时，capacity不会被缩小，只有size会被resize所修改。</p>
<p>还有一种实验，我们一直<code>push_back</code>count个元素一直打印这两个值，会发现，部分情况下size等于capacity，但大部分情况下capacity会大于size。这也是因为vector动态分配空间所导致的。那么这样刚好说下为什么，最上面代码使用<code>push_back</code>和<code>emplace_back</code>效率远低于<code>resize</code>的原因。</p>
<h2 id="push-back过程"><a href="#push-back过程" class="headerlink" title="push_back过程"></a>push_back过程</h2><p>push_back是向容器vec尾部插入一个元素，如果此时size小于cap，则直接插入即可。如果此时size已经等于cap，那么STL会重新申请一块两倍于此时cap容量的连续内存，先将之前的内存拷贝到此处，再在其尾部插入这个新元素。所以，从零开始一个一个插入元素势必会进行巨量的这个过程，也就带来了大量的时间花销。</p>
<p>此外，对于vector每次扩容是否是两倍的这个说法，网上也有些不同的说法，在此不细究，我自己试验下来，小数目情况下确实是两倍。非两倍情况可能是STL版本或者数量大的情况不一样。附测试代码和结果，环境为<code>linux</code>+<code>gcc9.2</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec6;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)&#123;</span><br><span class="line">    vec6.push_back(i);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt;vec6.size()&lt;&lt;<span class="string">&quot;  cap: &quot;</span>&lt;&lt;vec6.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2021/03/23/vector%E6%8F%92%E5%85%A5n%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/image-20210323231146512.png" class="" title="image-20210323231146512">

<h2 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h2><p>上面代码第一第二种方法虽然差距很小，但仍然还是有一点细微的时间差距。在此也记录一下这两者之间的区别。</p>
<p><strong>对于最终结果来说，这两个函数是一样的，都是将一个元素插入到容器最后。</strong></p>
<p>其中<code>emplace_back()</code>函数是C++11新增加的，那么既然功能完全一样，C++11引入它的原因是什么呢。</p>
<p><code>emplace_back()</code> 和 <code>push_back()</code> 的区别，就在于底层实现的机制不同。<code>push_back()</code> 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）；而 emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。有如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    testDemo(<span class="keyword">int</span> num):num(num)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(<span class="keyword">const</span> testDemo&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo(testDemo&amp;&amp; other) :num(other.num) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo1;</span><br><span class="line">    demo1.emplace_back(<span class="number">2</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;push_back:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;testDemo&gt; demo2;</span><br><span class="line">    demo2.push_back(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br></pre></td></tr></table></figure>
<p>在此基础上，尝试将 testDemo 类中的移动构造函数注释掉，再运行程序会发现，运行结果变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emplace_back:</span><br><span class="line">调用构造函数</span><br><span class="line">push_back:</span><br><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数</span><br></pre></td></tr></table></figure>
<p>由此可以看出，push_back() 在底层实现时，会优先选择调用移动构造函数，如果没有才会调用拷贝构造函数。</p>
<p>显然完成同样的操作，push_back() 的底层实现过程比 emplace_back() 更繁琐，换句话说，emplace_back() 的执行效率比 push_back() 高。<strong>因此，在实际使用时，建议优先选用emplace_back()。</strong></p>
<p>但是，由于 emplace_back() 是 C++ 11 标准新增加的，如果程序要兼顾之前的版本，还是应该使用 push_back()。且对于基础类型或者内容很小的类来说，这两者也不会带来太大的性能差异。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://c.biancheng.net/view/6826.html">C++ STL vector添加元素（push_back()和emplace_back()）详解</a></p>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>cpp</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown学习</title>
    <url>/2017/07/02/markdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>既然想着开始用github+hexo写博客了，那么最入门的就是学习一下markdown的书写语法了。</p>
<a id="more"></a>

<h1 id="1-MarkDown简要语法"><a href="#1-MarkDown简要语法" class="headerlink" title="1.MarkDown简要语法"></a>1.MarkDown简要语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。<br>#一级标题<br>##二级标题<br>以此类推，markdown一共支持六级标题划分  </p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>在html中列表分为有序列表和无序列表两种。在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。如：  </p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul>
<li>1</li>
<li>2</li>
<li>3  </li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol>
<li>甲</li>
<li>乙</li>
<li>丙</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>如果需要引用别处的一些语句，则需要在文本前加入&gt;(尖括号),如  </p>
<blockquote>
<p>引用文本</p>
</blockquote>
<h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><p>插入链接与插入图片的语法很像，区别在一个 !号<br>图片为：<img src="http://qmgvbv5fp.hd-bkt.clouddn.com/1.jpg" alt="测试图片"><br>链接为：<a href=""></a><br>插入图片的地址需要图床，暂时就不推荐了，有了图床生成URL地址即可。<br><a href="jxlxy1995.github.io">链接</a><br>图片示例待添加</p>
<h2 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h2><p>Markdown 的粗体和斜体与我所看到的部分文章不符，用两个星号包含一段文本就是斜体的语法，用两段下划线包含一段文本就是粗体的语法。<br>例如，<em>这里是斜体</em>  <strong>这里是粗体</strong></p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格是我觉得 Markdown 比较累人的地方，例子如下:<br>    | Tables        | Are           | Cool  |<br>    | ————- |:————-:| —–:|<br>    | col 3 is      | right-aligned | $1600 |<br>    | col 2 is      | centered      |   $12 |<br>    | zebra stripes | are neat      |    $1 |<br>效果如下：  </p>
<table>
<thead>
<tr>
<th>Tables</th>
<th align="center">Are</th>
<th align="right">Cool</th>
</tr>
</thead>
<tbody><tr>
<td>col 3 is</td>
<td align="center">right-aligned</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>作为一个程序员肯定是需要有代码出现在文章中的，这时就需要引入代码框了。在 Markdown下实现也非常简单，起始三个点号(波浪号那个键)+语言，结尾三个点号即可。<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello MarkDown\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>分割线的语法只需要三个 * 号，例如:  </p>
<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。<br>本文为本人学习markdown语法练手所写，内容基本转自简书一篇文章，<a href="http://www.jianshu.com/p/1e402922ee32/">原文链接</a>。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>其他技术</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2017/07/02/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>开始记录一些东西吧，希望自己可以坚持下去~~</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下Socket编程</title>
    <url>/2021/01/26/linux%E4%B8%8BSocket%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>游戏服务器开发说到底根本技术在两点网络通信和数据库读写，所以最近先把linux下的socket编程再系统复习一遍。</p>
<a id="more"></a>

<h1 id="Linux下的一个简单网络通信程序"><a href="#Linux下的一个简单网络通信程序" class="headerlink" title="Linux下的一个简单网络通信程序"></a>Linux下的一个简单网络通信程序</h1><p>废话少说先直接上两个简单的示例代码</p>
<p>server.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1400</span>);  <span class="comment">//端口</span></span><br><span class="line">    bind(serv_sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态，等待用户发起请求</span></span><br><span class="line">    <span class="comment">//listen(serv_sock, SOMAXCONN);</span></span><br><span class="line">    listen(serv_sock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    <span class="keyword">int</span> clientCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">        <span class="keyword">int</span> clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == clnt_sock)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ++clientCount;</span><br><span class="line">        <span class="comment">//向客户端发送数据</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;hello client&quot;</span> + <span class="built_in">std</span>::to_string(clientCount);</span><br><span class="line">        write(clnt_sock, str.c_str(), str.length());</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//关闭套接字</span></span><br><span class="line">        close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器（特定的IP和端口）发起请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1400</span>);  <span class="comment">//端口</span></span><br><span class="line">    connect(sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//读取服务器传回的数据</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>];</span><br><span class="line">    read(sock, buffer, <span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, buffer);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是最简单的服务器客户端示例，开启server程序监听后，开启client程序会对server连接，打印收到的服务器下发的字符串。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>首先通过 socket() 函数创建了一个套接字，参数 AF_INET 表示使用 IPv4 地址，SOCK_STREAM 表示使用面向连接的套接字，IPPROTO_TCP 表示使用 TCP 协议。在 Linux 中，socket 也是一种文件，有文件描述符，可以使用 write() / read() 函数进行 I/O 操作。</p>
<p>通过 bind() 函数将套接字 serv_sock 与特定的 IP 地址和端口绑定，IP 地址和端口都保存在 sockaddr_in 结构体中。socket() 函数确定了套接字的各种属性，bind() 函数让套接字与特定的IP地址和端口对应起来，这样客户端才能连接到该套接字。</p>
<p>listen()让套接字处于监听状态。所谓监听，是指套接字一直处于“睡眠”中，直到客户端发起请求才会被“唤醒”。</p>
<p>accept() 函数用来接收客户端的请求。程序一旦执行到 accept() 就会被阻塞（暂停运行），直到客户端发起请求。</p>
<p>write() 函数用来向套接字文件中写入数据，也就是向客户端发送数据。</p>
<p>和普通文件(再次体现了linux下一切皆文件，fd文件描述符亦是)一样，socket 在使用完毕后也要用 close() 关闭。</p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>client中创建套接字以及对应结构体和server一样，就不赘述了。</p>
<p>connect() 向服务器发起请求，服务器的IP地址和端口号保存在 sockaddr_in 结构体中。直到服务器传回数据后，connect() 才运行结束。</p>
<p>read() 从套接字文件中读取数据。</p>
<h1 id="linux下socket相关函数"><a href="#linux下socket相关函数" class="headerlink" title="linux下socket相关函数"></a>linux下socket相关函数</h1><p>下面分别来分析在 Linux 下使用 &lt;sys/socket.h&gt; 头文件中几个重要函数。下面涉及到的函数源码，均是在CentOS Linux release 7.5.1804版本下摘抄。</p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h2><p>原型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new socket of type TYPE in domain DOMAIN, using</span></span><br><span class="line"><span class="comment">   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.</span></span><br><span class="line"><span class="comment">   Returns a file descriptor for the new socket, or -1 for errors.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">socket</span> <span class="params">(<span class="keyword">int</span> __domain, <span class="keyword">int</span> __type, <span class="keyword">int</span> __protocol)</span> __THROW</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>__domain: 这个参数本身含义是指通信中的“域”的含义，网上大部分文章更愿意叫这个参数按老版本函数原型<code>int af</code>中的<code>af</code>的原意–Address Family。就是地址族，从参数本身意义来说也就是IP地址类型。常用的有 AF_INET 和 AF_INET6。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 fe80:0000:0001:0000:0440:44ff:1233:5678。</p>
<blockquote>
<p>也可以使用 PF 前缀，PF 是“Protocol Family”的简写，它和 AF 是一样的。例如，PF_INET 等价于 AF_INET，PF_INET6 等价于 AF_INET6。</p>
</blockquote>
</li>
<li><p>__type: 为数据传输方式/套接字类型，常用的有 <strong>SOCK_STREAM（流格式套接字/面向连接的套接字）</strong> 和 <strong>SOCK_DGRAM（数据报套接字/无连接的套接字）</strong></p>
</li>
<li><p>__protocol: protocol 表示传输协议，常用的有 <strong>IPPROTO_TCP</strong> 和 <strong>IPPTOTO_UDP</strong>，分别表示 TCP 传输协议和 UDP 传输协议。</p>
</li>
</ol>
<p>有个问题，有了地址类型和数据传输方式，还不足以决定采用哪种协议吗？为什么还需要第三个参数呢？</p>
<p>一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。（因为我只用过tcp和udp两种，所以暂时还不了解有没有这种情况真实存在）</p>
<p>那么tcp和udp创建套接字代码也可以简写成如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//创建TCP套接字</span></span><br><span class="line"><span class="keyword">int</span> udp_socket = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);  <span class="comment">//创建UDP套接字</span></span><br></pre></td></tr></table></figure>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>原型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Give the socket FD the local address ADDR (which is LEN bytes long).  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">bind</span> <span class="params">(<span class="keyword">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="keyword">socklen_t</span> __len)</span></span></span><br><span class="line"><span class="function">     __THROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __CONST_SOCKADDR_ARG定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CONST_SOCKADDR_ARG	const struct sockaddr *</span></span><br></pre></td></tr></table></figure>
<p>fd为socket文件描述符，addr为sockaddr结构体指针，len为addr变量的大小，可由sizeof()计算得出。</p>
<p>下面的代码，将创建套接字，并使其与ip地址127.0.0.1、端口2222绑定：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line"><span class="keyword">int</span> servSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建sockaddr_in结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servAddr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAddr));  <span class="comment">//初始化</span></span><br><span class="line">servAddr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">servAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//要绑定的IP地址</span></span><br><span class="line">servAddr.sin_port = htons(<span class="number">2222</span>);  <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line">bind(servSocket, (struct sockaddr*)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr));</span><br></pre></td></tr></table></figure>
<p>上面代码使用了sockaddr_in结构体，然后再强制转换成sockaddr类型，后面会提到为什么要这样做。</p>
<h3 id="sockaddr-in-结构体"><a href="#sockaddr-in-结构体" class="headerlink" title="sockaddr_in 结构体"></a>sockaddr_in 结构体</h3><p>原型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Structure describing an Internet socket address.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;			<span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>		<span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">                           __SOCKADDR_COMMON_SIZE -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (struct in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>__SOCKADDR_COMMON就是成员sin_family ，外层又一个宏定义，这个包装先不细究。sin_family和socket()的第一个参数含义相同，取值也要保持一致。</li>
<li>sin_prot 为端口号。in_port_t最终类型是int16，它的长度为两个字节，理论上端口号的取值范围为 0<del>65536，但 0</del>1023 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 1024~65536 之间分配端口号。端口号需要用htons()进行转换，这个后面有机会也做一下记录，网络大小端的转换。</li>
<li>sin_addr 是 struct in_addr 结构体类型的变量，下面会详细讲解。</li>
<li>sin_zero[8] 是多余的8个字节(根据ide显示其中算式算出来是8)，暂时不关注，一般使用 memset() 函数填充为 0。上面的代码中，先用 memset() 将结构体的全部字节填充为 0，再给前3个成员赋值，剩下的 sin_zero 自然就是 0 了。</li>
</ol>
<h3 id="in-addr结构体"><a href="#in-addr结构体" class="headerlink" title="in_addr结构体"></a>in_addr结构体</h3><p>sockaddr_in 的第3个成员是 in_addr 类型的结构体，该结构体只包含一个成员，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Internet address.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>in_addr_t 在头文件 &lt;netinet/in.h&gt; 中定义，等价于 unsigned long，长度为4个字节。也就是说，s_addr 是一个整数，而IP地址是一个字符串，所以需要 inet_addr() 函数进行转换，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long ip &#x3D; inet_addr(&quot;127.0.0.1&quot;);</span><br><span class="line">printf(&quot;%ld\n&quot;, ip);</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>16777343</p>
<img src="/2021/01/26/linux%E4%B8%8BSocket%E7%BC%96%E7%A8%8B/%E5%9B%BE%E8%A7%A3sockaddr_in%E7%BB%93%E6%9E%84%E4%BD%93-1613028044984.jpg" class="" title="图解sockaddr_in结构体">

<p>为什么要搞这么复杂，结构体中嵌套结构体，而不用 sockaddr_in 的一个成员变量来指明IP地址呢？</p>
<p>这或许是历史原因吧，后面的接口总要兼容前面的代码。暂时不理解没有关系，后续看有没有机会知道原因。</p>
<h3 id="为什么使用sockaddr-in而不使用sockaddr"><a href="#为什么使用sockaddr-in而不使用sockaddr" class="headerlink" title="为什么使用sockaddr_in而不使用sockaddr"></a>为什么使用sockaddr_in而不使用sockaddr</h3><p>bind() 第二个参数的类型为 sockaddr，而代码中却使用 sockaddr_in，然后再强制转换为 sockaddr，这是为什么呢？</p>
<p>sockaddr 结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Structure describing a generic socket address.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__SOCKADDR_COMMON (sa_);	<span class="comment">/* Common data: address family and length.  */</span></span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>];		<span class="comment">/* Address data.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下图是 sockaddr 与 sockaddr_in 的对比（括号中的数字表示所占用的字节数,__SOCKADDR_COMMON依旧是sin_family的宏定义）：</p>


<p>sockaddr 和 sockaddr_in 的长度相同，都是16字节，只是将IP地址和端口号合并到一起，用一个成员 sa_data 表示。要想给 sa_data 赋值，必须同时指明IP地址和端口号，例如”127.0.0.1:80“，遗憾的是，没有相关函数将这个字符串转换成需要的形式，也就很难给 sockaddr 类型的变量赋值，所以使用 sockaddr_in 来代替。这两个结构体的长度相同，强制转换类型时不会丢失字节，也没有多余的字节。</p>
<p><strong>可以认为，sockaddr 是一种通用的结构体，可以用来保存多种类型的IP地址和端口号，而 sockaddr_in 是专门用来保存 IPv4 地址的结构体。</strong>另外还有 sockaddr_in6，用来保存 IPv6 地址，它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__USE_KERNEL_IPV6_DEFS</span></span><br><span class="line"><span class="comment">/* Ditto, for IPv6.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin6_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port;	<span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo;	<span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>	<span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;	<span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !__USE_KERNEL_IPV6_DEFS */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>正是由于通用结构体 sockaddr 使用不便，才针对不同的地址类型定义了不同的结构体。</strong></p>
<h2 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect()函数"></a>connect()函数</h2><p>connect() 函数用来建立连接，它的原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).</span></span><br><span class="line"><span class="comment">   For connectionless socket types, just set the default address to send to</span></span><br><span class="line"><span class="comment">   and the only address from which to accept transmissions.</span></span><br><span class="line"><span class="comment">   Return 0 on success, -1 for errors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">connect</span> <span class="params">(<span class="keyword">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="keyword">socklen_t</span> __len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>各个参数的说明和 bind() 相同，不再赘述。</p>
<h2 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen()函数"></a>listen()函数</h2><p>对于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态，再调用 accept() 函数，就可以随时响应客户端的请求了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Prepare to accept connections on socket FD.</span></span><br><span class="line"><span class="comment">   N connection requests will be queued before further requests are refused.</span></span><br><span class="line"><span class="comment">   Returns 0 on success, -1 for errors.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">listen</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">int</span> __n)</span> __THROW</span>;</span><br></pre></td></tr></table></figure>
<p>__fd为要监听的套接字，n为请求队列的最大长度。</p>
<p>所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。</p>
<h3 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h3><p>当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为<strong>请求队列（Request Queue）</strong>。</p>
<p>缓冲区的长度（能存放多少个客户端请求）可以通过 listen() 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是10或者20。</p>
<p>如果将 n的值设置为 SOMAXCONN(也在socket.h文件中)，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Maximum queue length specifiable by listen.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOMAXCONN	128</span></span><br></pre></td></tr></table></figure>
<p>当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。</p>
<p>注意：listen() 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept() 函数。</p>
<h2 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept() 函数"></a>accept() 函数</h2><p>当套接字处于监听状态时，可以通过 accept() 函数来接收客户端请求。它的原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Await a connection on socket FD.</span></span><br><span class="line"><span class="comment">   When a connection arrives, open a new socket to communicate with it,</span></span><br><span class="line"><span class="comment">   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting</span></span><br><span class="line"><span class="comment">   peer and *ADDR_LEN to the address&#x27;s actual length, and return the</span></span><br><span class="line"><span class="comment">   new socket&#x27;s descriptor, or -1 for errors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">accept</span> <span class="params">(<span class="keyword">int</span> __fd, __SOCKADDR_ARG __addr,</span></span></span><br><span class="line"><span class="function"><span class="params">		   <span class="keyword">socklen_t</span> *__restrict __addr_len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它的参数与 listen() 和 connect() 是相同的：fd为服务器端套接字，addr 为 sockaddr_in 结构体变量，addr__len 为参数 addr 的长度，可由 sizeof() 求得。</p>
<p><strong>accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，要注意区分</strong>。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。</p>
<p>最后需要说明的是：listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行，直到有新的请求到来。</p>
<h2 id="write-read"><a href="#write-read" class="headerlink" title="write()/read()"></a>write()/read()</h2><p>Linux 不区分套接字文件和普通文件，使用 write() 可以向套接字中写入数据，使用 read() 可以从套接字中读取数据。</p>
<p>在linux下，两台计算机之间的通信相当于两个套接字之间的通信，在服务器端用 write() 向套接字写入数据，客户端就能收到，然后再使用 read() 从套接字中读取出来，就完成了一次通信。</p>
<p>write()的原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Write N bytes of BUF to FD.  Return the number written, or -1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">const</span> <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __n)</span> __wur</span>;</span><br></pre></td></tr></table></figure>
<p>fd 为要写入的文件的描述符，buf 为要写入的数据的缓冲区地址，n 为要写入的数据的字节数。</p>
<blockquote>
<p>size_t 是通过 typedef 声明的 unsigned int 类型；ssize_t 在 “size_t” 前面加了一个”s”，代表 signed，即 ssize_t 是通过 typedef 声明的 signed int 类型。</p>
</blockquote>
<p>write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。</p>
<p>read() 的原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Read NBYTES into BUF from FD.  Return the</span></span><br><span class="line"><span class="comment">   number read, -1 for errors or 0 for EOF.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">ssize_t</span> <span class="title">read</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __nbytes)</span> __wur</span>;</span><br></pre></td></tr></table></figure>
<p>fd 为要读取的文件的描述符，buf 为要接收数据的缓冲区地址，nbytes 为要读取的数据的字节数。</p>
<p>read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1。</p>
<p>以上就是linux下socket编程主要用的的一些函数的介绍，后面应该会写一个简易的网络框架来作为实践，再有更深入的网络编程知识会另起文章记录。</p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
